<!DOCTYPE html>

<html>
<head>
  <title>validate.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>validate.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <pre><code>Validate.js <span class="hljs-number">0.4</span><span class="hljs-number">.0</span>
(c) <span class="hljs-number">2013</span>-<span class="hljs-number">2015</span> Nicklas Ansman, <span class="hljs-number">2013</span> Wrapp
Validate.js may be freely distributed under the MIT license.
For all details and documentation:
http:<span class="hljs-comment">//validatejs.org/</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(exports, module, define, require)</span> </span>{
<span class="hljs-pi">  "use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>The main function that calls the validators specified by the constraints.
The options are the following:</p>
<ul>
<li>flatten (boolean) - If <code>true</code> will return a flat array instead of an object.</li>
<li>fullMessages (boolean) - If <code>true</code> (default) the attribute name is prepended to the error.</li>
</ul>
<p>Please note that the options are also passed to each validator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> validate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(attributes, constraints, options)</span> </span>{
    options = v.extend({}, v.options, options);

    <span class="hljs-keyword">var</span> results = v.runValidations(attributes, constraints, options)
      , attr
      , validator;

    <span class="hljs-keyword">for</span> (attr <span class="hljs-keyword">in</span> results) {
      <span class="hljs-keyword">for</span> (validator <span class="hljs-keyword">in</span> results[attr]) {
        <span class="hljs-keyword">if</span> (v.isPromise(results[attr][validator])) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Use validate.async if you want support for promises"</span>);
        }
      }
    }
    <span class="hljs-keyword">return</span> validate.processValidationResults(results, options);
  };

  <span class="hljs-keyword">var</span> v = validate
    , root = <span class="hljs-keyword">this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Finds %{key} style patterns in the given string</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    , FORMAT_REGEXP = <span class="hljs-regexp">/%\{([^\}]+)\}/g</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Copies over attributes from one or more sources to a single destination.
Very much similar to underscore’s extend.
The first argument is the target object and the remaining arguments will be
used as targets.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  v.extend = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj)</span> </span>{
    [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(source)</span> </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> attr <span class="hljs-keyword">in</span> source) {
        obj[attr] = source[attr];
      }
    });
    <span class="hljs-keyword">return</span> obj;
  };

  v.extend(validate, {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>This “class” is just a wrapper around a dictionary and is here to allow
you to differentiate between library errors and validation errors
when using promises.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    ValidationErrors: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(errors)</span> </span>{
      v.extend(<span class="hljs-keyword">this</span>, errors);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Runs the validators specified by the constraints object.
Will return an array of the format:
    [{attribute: “<attribute name>“, error: “<validation result>“}, …]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    runValidations: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(attributes, constraints, options)</span> </span>{
      <span class="hljs-keyword">var</span> results = []
        , attr
        , validatorName
        , value
        , validators
        , validator
        , validatorOptions
        , error;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Loops through each constraints, finds the correct validator and run it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">for</span> (attr <span class="hljs-keyword">in</span> constraints) {
        value = v.getDeepObjectValue(attributes, attr);
        validators = v.result(constraints[attr], value, attributes, attr);

        <span class="hljs-keyword">for</span> (validatorName <span class="hljs-keyword">in</span> validators) {
          validator = v.validators[validatorName];

          <span class="hljs-keyword">if</span> (!validator) {
            error = v.format(<span class="hljs-string">"Unknown validator %{name}"</span>, {name: validatorName});
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(error);
          }

          validatorOptions = validators[validatorName];</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>This allows the options to be a function. The function will be
called with the value, attribute name and the complete dict of
attributes. This is useful when you want to have different
validations depending on the attribute value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          validatorOptions = v.result(validatorOptions, value, attributes, attr);
          <span class="hljs-keyword">if</span> (!validatorOptions) {
            <span class="hljs-keyword">continue</span>;
          }
          results.push({
            attribute: attr,
            error: validator.call(validator, value, validatorOptions, attr,
                                  attributes)
          });
        }
      }

      <span class="hljs-keyword">return</span> results;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Takes the output from runValidations and converts it to the correct
output format.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    processValidationResults: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(results, options)</span> </span>{
      <span class="hljs-keyword">var</span> errors = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>This indexes the errors per attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      results.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(result)</span> </span>{
        <span class="hljs-keyword">var</span> error = result.error
          , attribute = result.attribute;

        <span class="hljs-keyword">if</span> (v.isString(error)) {
          error = [error];
        }

        <span class="hljs-keyword">if</span> (error) {
          errors[attribute] = (errors[attribute] || []).concat(error);
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Semi ugly way to check if the errors are empty, try iterating over
them and short circuit when something is found.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _ <span class="hljs-keyword">in</span> errors) {
        <span class="hljs-keyword">return</span> v.fullMessages(errors, options);
      }
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Runs the validations with support for promises.
This function will return a promise that is settled when all the
validation promises have been completed.
It can be called even if no validations returned a promise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    async: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(attributes, constraints, options)</span> </span>{
      options = v.extend({}, v.async.options, options);
      <span class="hljs-keyword">var</span> results = v.runValidations(attributes, constraints, options);

      <span class="hljs-keyword">return</span> v.Promise(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(resolve, reject)</span> </span>{
        v.waitForResults(results).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
          <span class="hljs-keyword">var</span> errors = v.processValidationResults(results, options);
          <span class="hljs-keyword">if</span> (errors) {
            <span class="hljs-keyword">if</span> (!options.flatten) {
              errors = <span class="hljs-keyword">new</span> v.ValidationErrors(errors);
            }
            reject(errors);
          } <span class="hljs-keyword">else</span> {
            resolve(attributes);
          }
        }).then(<span class="hljs-literal">undefined</span>, v.error);
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Returns a promise that is resolved when all promises in the results array
are settled. The promise returned from this function is always resolved,
never rejected.
This function modifies the input argument, it replaces the promises
with the value returned from the promise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    waitForResults: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(results)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Create a sequence of all the results starting with a resolved promise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> promise = results.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(memo, result)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>If this result isn’t a promise skip it in the sequence.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!v.isPromise(result.error)) {
          <span class="hljs-keyword">return</span> memo;
        }

        <span class="hljs-keyword">return</span> memo.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
          <span class="hljs-keyword">return</span> result.error.then(
            <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
              result.error = <span class="hljs-literal">null</span>;
            },
            <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>If for some reason the validator promise was rejected but no
error was specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (!error) {
                v.warn(<span class="hljs-string">"Validator promise was rejected but didn't return an error"</span>);
              }
              result.error = error;
            }
          ).then(<span class="hljs-literal">undefined</span>, v.error);
        }).then(<span class="hljs-literal">undefined</span>, v.error);
      }, v.Promise(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(r)</span> </span>{ r(); })); <span class="hljs-comment">// A resolved promise</span>

      <span class="hljs-keyword">return</span> promise.then(<span class="hljs-literal">undefined</span>, v.error);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>If the given argument is a call: function the and: function return the value
otherwise just return the value. Additional arguments will be passed as
arguments to the function.
Example:</p>
<pre><code>result(<span class="hljs-string">'foo'</span>) <span class="hljs-comment">// 'foo'</span>
result(<span class="hljs-built_in">Math</span>.max, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 2</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>    result: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> </span>{
      <span class="hljs-keyword">var</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'function'</span>) {
        value = value.apply(<span class="hljs-literal">null</span>, args);
      }
      <span class="hljs-keyword">return</span> value;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Checks if the value is a number. This function does not consider NaN a
number like many other <code>isNumber</code> functions do.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    isNumber: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'number'</span> &amp;&amp; !<span class="hljs-built_in">isNaN</span>(value);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Returns false if the object is not a function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    isFunction: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'function'</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>A simple check to verify that the value is an integer. Uses <code>isNumber</code>
and a simple modulo check.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    isInteger: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> </span>{
      <span class="hljs-keyword">return</span> v.isNumber(value) &amp;&amp; value % <span class="hljs-number">1</span> === <span class="hljs-number">0</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Uses the <code>Object</code> function to check if the given argument is an object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    isObject: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj)</span> </span>{
      <span class="hljs-keyword">return</span> obj === <span class="hljs-built_in">Object</span>(obj);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Returns false if the object is <code>null</code> of <code>undefined</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    isDefined: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj)</span> </span>{
      <span class="hljs-keyword">return</span> obj !== <span class="hljs-literal">null</span> &amp;&amp; obj !== <span class="hljs-literal">undefined</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Checks if the given argument is a promise. Anything with a <code>then</code>
function is considered a promise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    isPromise: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(p)</span> </span>{
      <span class="hljs-keyword">return</span> !!p &amp;&amp; <span class="hljs-keyword">typeof</span> p.then === <span class="hljs-string">'function'</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Formats the specified strings with the given values like so:</p>
<pre><code>format(<span class="hljs-string">"Foo: %{foo}"</span>, {foo: <span class="hljs-string">"bar"</span>}) <span class="hljs-comment">// "Foo bar"</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>    format: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(str, vals)</span> </span>{
      <span class="hljs-keyword">return</span> str.replace(FORMAT_REGEXP, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(m0, m1)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(vals[m1]);
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>“Prettifies” the given string.
Prettifying means replacing [._-] with spaces as well as splitting
camel case words.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    prettify: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(str)</span> </span>{
      <span class="hljs-keyword">return</span> str</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Splits keys separated by periods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        .replace(<span class="hljs-regexp">/([^\s])\.([^\s])/g</span>, <span class="hljs-string">'$1 $2'</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Removes backslashes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        .replace(<span class="hljs-regexp">/\\+/g</span>, <span class="hljs-string">''</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Replaces - and - with space</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        .replace(<span class="hljs-regexp">/[_-]/g</span>, <span class="hljs-string">' '</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Splits camel cased words</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        .replace(<span class="hljs-regexp">/([a-z])([A-Z])/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(m0, m1, m2)</span> </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-string">""</span> + m1 + <span class="hljs-string">" "</span> + m2.toLowerCase();
        })
        .toLowerCase();
    },

    isString: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>;
    },

    isArray: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> </span>{
      <span class="hljs-keyword">return</span> {}.toString.call(value) === <span class="hljs-string">'[object Array]'</span>;
    },

    contains: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj, value)</span> </span>{
      <span class="hljs-keyword">if</span> (!v.isDefined(obj)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">if</span> (v.isArray(obj)) {
        <span class="hljs-keyword">return</span> obj.indexOf(value) !== -<span class="hljs-number">1</span>;
      }
      <span class="hljs-keyword">return</span> value <span class="hljs-keyword">in</span> obj;
    },

    getDeepObjectValue: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj, keypath)</span> </span>{
      <span class="hljs-keyword">if</span> (!v.isObject(obj) || !v.isString(keypath)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      }

      <span class="hljs-keyword">var</span> key = <span class="hljs-string">""</span>
        , i
        , <span class="hljs-built_in">escape</span> = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; keypath.length; ++i) {
        <span class="hljs-keyword">switch</span> (keypath[i]) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>:
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">escape</span>) {
              <span class="hljs-built_in">escape</span> = <span class="hljs-literal">false</span>;
              key += <span class="hljs-string">'.'</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> obj) {
              obj = obj[key];
              key = <span class="hljs-string">""</span>;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
            }
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'\\'</span>:
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">escape</span>) {
              <span class="hljs-built_in">escape</span> = <span class="hljs-literal">false</span>;
              key += <span class="hljs-string">'\\'</span>;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-built_in">escape</span> = <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">default</span>:
            <span class="hljs-built_in">escape</span> = <span class="hljs-literal">false</span>;
            key += keypath[i];
            <span class="hljs-keyword">break</span>;
        }
      }

      <span class="hljs-keyword">if</span> (v.isDefined(obj) &amp;&amp; key <span class="hljs-keyword">in</span> obj) {
        <span class="hljs-keyword">return</span> obj[key];
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      }
    },

    capitalize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(str)</span> </span>{
      <span class="hljs-keyword">if</span> (!v.isString(str)) {
        <span class="hljs-keyword">return</span> str;
      }
      <span class="hljs-keyword">return</span> str[<span class="hljs-number">0</span>].toUpperCase() + str.slice(<span class="hljs-number">1</span>);
    },

    fullMessages: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(errors, options)</span> </span>{
      options = options || {};

      <span class="hljs-keyword">var</span> ret = options.flatten ? [] : {}
        , attr;

      <span class="hljs-keyword">if</span> (!errors) {
        <span class="hljs-keyword">return</span> ret;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processErrors</span><span class="hljs-params">(attr, errors)</span> </span>{
        errors.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
          <span class="hljs-keyword">if</span> (error[<span class="hljs-number">0</span>] === <span class="hljs-string">'^'</span>) {
            error = error.slice(<span class="hljs-number">1</span>);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.fullMessages !== <span class="hljs-literal">false</span>) {
            error = v.format(<span class="hljs-string">"%{attr} %{message}"</span>, {
              attr: v.capitalize(v.prettify(attr)),
              message: error
            });
          }
          error = error.replace(<span class="hljs-regexp">/\\\^/g</span>, <span class="hljs-string">"^"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>If flatten is true a flat array is returned.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (options.flatten) {
            ret.push(error);
          }
          <span class="hljs-keyword">else</span> {
            (ret[attr] || (ret[attr] = [])).push(error);
          }
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Converts the errors of object of the format
{attr: [<error>, <error>, …]} to contain the attribute name.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">for</span> (attr <span class="hljs-keyword">in</span> errors) {
        processErrors(attr, errors[attr]);
      }
      <span class="hljs-keyword">return</span> ret;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Returns a promise, should be called with the new operator.
The first argument will be called with two functions, the first for
resolving the promise and the second for rejecting it.
Supports (in order of precedence):</p>
<ul>
<li>EcmaScript 6 Promises</li>
<li>RSVP</li>
<li>when</li>
<li>Q</li>
</ul>
<p>If no supported promises are detected an error is thrown.
A word of warning, only A+ style promises are supported. jQuery deferreds
are NOT supported.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Promise: v.extend(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span> </span>{
      <span class="hljs-keyword">var</span> promise = v.Promise.nativePromise(callback) ||
                    v.Promise.RSVPPromise(callback) ||
                    v.Promise.whenPromise(callback) ||
                    v.Promise.QPromise(callback);

      <span class="hljs-keyword">if</span> (!promise) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"No promises could be detected"</span>);
      }

      <span class="hljs-keyword">return</span> promise;
    }, {
      nativePromise: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span> </span>{
        <span class="hljs-keyword">var</span> Promise_, <span class="hljs-built_in">module</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Promise !== <span class="hljs-string">"undefined"</span>) {
          Promise_ = Promise;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-built_in">module</span> = v.tryRequire(<span class="hljs-string">"es6-promise"</span>);
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>) {
            Promise_ = <span class="hljs-built_in">module</span>.Promise;
          }
        }
        <span class="hljs-keyword">if</span> (Promise_) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise_(callback);
        }
      },
      RSVPPromise: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span> </span>{
        <span class="hljs-keyword">var</span> Promise, <span class="hljs-built_in">module</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> RSVP !== <span class="hljs-string">"undefined"</span>) {
          Promise = RSVP.Promise;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-built_in">module</span> = v.tryRequire(<span class="hljs-string">"rsvp"</span>);
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>) {
            Promise = <span class="hljs-built_in">module</span>.Promise;
          }
        }
        <span class="hljs-keyword">if</span> (Promise) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(callback);
        }
      },
      whenPromise: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span> </span>{
        <span class="hljs-keyword">var</span> promise, <span class="hljs-built_in">module</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> when !== <span class="hljs-string">"undefined"</span>) {
          promise = when.promise;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-built_in">module</span> = v.tryRequire(<span class="hljs-string">"when"</span>);
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>) {
            promise = <span class="hljs-built_in">module</span>.promise;
          }
        }
        <span class="hljs-keyword">if</span> (promise) {
          <span class="hljs-keyword">return</span> promise(callback);
        }
      },
      QPromise: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span> </span>{
        <span class="hljs-keyword">var</span> promise, <span class="hljs-built_in">module</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Q !== <span class="hljs-string">"undefined"</span>) {
          promise = Q.promise;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-built_in">module</span> = v.tryRequire(<span class="hljs-string">"q"</span>);
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>) {
            promise = <span class="hljs-built_in">module</span>.promise;
          }
        }
        <span class="hljs-keyword">if</span> (promise) {
          <span class="hljs-keyword">return</span> promise(callback);
        }
      }
    }),

    tryRequire: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(moduleName)</span> </span>{
      <span class="hljs-keyword">if</span> (!v.require) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> v.require(moduleName);
      } <span class="hljs-keyword">catch</span>(e) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    },

    <span class="hljs-built_in">require</span>: <span class="hljs-built_in">require</span>,

    exposeModule: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(validate, root, exports, module, define)</span> </span>{
      <span class="hljs-keyword">if</span> (exports) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span> &amp;&amp; <span class="hljs-built_in">module</span>.exports) {
          exports = <span class="hljs-built_in">module</span>.exports = validate;
        }
        exports.validate = validate;
      }
      <span class="hljs-keyword">else</span> {
        root.validate = validate;
        <span class="hljs-keyword">if</span> (validate.isFunction(define) &amp;&amp; define.amd) {
          define(<span class="hljs-string">"validate"</span>, [], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> validate; });
        }
      }
    },

    warn: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(msg)</span> </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> !== <span class="hljs-string">"undefined"</span> &amp;&amp; <span class="hljs-built_in">console</span>.warn) {
        <span class="hljs-built_in">console</span>.warn(msg);
      }
    },

    error: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(msg)</span> </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> !== <span class="hljs-string">"undefined"</span> &amp;&amp; <span class="hljs-built_in">console</span>.error) {
        <span class="hljs-built_in">console</span>.error(msg);
      }
    }
  });

  validate.validators = {</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Presence validates that the value isn’t empty</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    presence: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, options)</span> </span>{
      options = v.extend({}, <span class="hljs-keyword">this</span>.options, options);

      <span class="hljs-keyword">var</span> message = options.message || <span class="hljs-keyword">this</span>.message || <span class="hljs-string">"can't be blank"</span>
        , attr;</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Null and undefined aren’t allowed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!v.isDefined(value)) {
        <span class="hljs-keyword">return</span> message;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>functions are ok</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (v.isFunction(value)) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Tests if the string contains only whitespace (tab, newline, space etc)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((<span class="hljs-regexp">/^\s*$/</span>).test(value)) {
          <span class="hljs-keyword">return</span> message;
        }
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v.isArray(value)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>For arrays we use the length property</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (value.length === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> message;
        }
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v.isObject(value)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>If we find at least one property we consider it non empty</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (attr <span class="hljs-keyword">in</span> value) {
          <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">return</span> message;
      }
    },
    length: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, options, attribute)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Null and undefined are fine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!v.isDefined(value)) {
        <span class="hljs-keyword">return</span>;
      }

      options = v.extend({}, <span class="hljs-keyword">this</span>.options, options);

      <span class="hljs-keyword">var</span> is = options.is
        , maximum = options.maximum
        , minimum = options.minimum
        , tokenizer = options.tokenizer || <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val)</span> </span>{ <span class="hljs-keyword">return</span> val; }
        , err
        , errors = [];

      value = tokenizer(value);
      <span class="hljs-keyword">var</span> length = value.length;
      <span class="hljs-keyword">if</span>(!v.isNumber(length)) {
        v.error(v.format(<span class="hljs-string">"Attribute %{attr} has a non numeric value for `length`"</span>, {attr: attribute}));
        <span class="hljs-keyword">return</span> options.message || <span class="hljs-keyword">this</span>.notValid || <span class="hljs-string">"has an incorrect length"</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Is checks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (v.isNumber(is) &amp;&amp; length !== is) {
        err = options.wrongLength ||
          <span class="hljs-keyword">this</span>.wrongLength ||
          <span class="hljs-string">"is the wrong length (should be %{count} characters)"</span>;
        errors.push(v.format(err, {count: is}));
      }

      <span class="hljs-keyword">if</span> (v.isNumber(minimum) &amp;&amp; length &lt; minimum) {
        err = options.tooShort ||
          <span class="hljs-keyword">this</span>.tooShort ||
          <span class="hljs-string">"is too short (minimum is %{count} characters)"</span>;
        errors.push(v.format(err, {count: minimum}));
      }

      <span class="hljs-keyword">if</span> (v.isNumber(maximum) &amp;&amp; length &gt; maximum) {
        err = options.tooLong ||
          <span class="hljs-keyword">this</span>.tooLong ||
          <span class="hljs-string">"is too long (maximum is %{count} characters)"</span>;
        errors.push(v.format(err, {count: maximum}));
      }

      <span class="hljs-keyword">if</span> (errors.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> options.message || errors;
      }
    },
    numericality: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, options)</span> </span>{
      <span class="hljs-keyword">if</span> (!v.isDefined(value)) {
        <span class="hljs-keyword">return</span>;
      }

      options = v.extend({}, <span class="hljs-keyword">this</span>.options, options);

      <span class="hljs-keyword">var</span> errors = []
        , name
        , count
        , checks = {
            greaterThan:          <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(v, c)</span> </span>{ <span class="hljs-keyword">return</span> v &gt; c; },
            greaterThanOrEqualTo: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(v, c)</span> </span>{ <span class="hljs-keyword">return</span> v &gt;= c; },
            equalTo:              <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(v, c)</span> </span>{ <span class="hljs-keyword">return</span> v === c; },
            lessThan:             <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(v, c)</span> </span>{ <span class="hljs-keyword">return</span> v &lt; c; },
            lessThanOrEqualTo:    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(v, c)</span> </span>{ <span class="hljs-keyword">return</span> v &lt;= c; }
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Coerce the value to a number unless we’re being strict.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (options.noStrings !== <span class="hljs-literal">true</span> &amp;&amp; v.isString(value)) {
        value = +value;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>If it’s not a number we shouldn’t continue since it will compare it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!v.isNumber(value)) {
        <span class="hljs-keyword">return</span> options.message || <span class="hljs-keyword">this</span>.notValid || <span class="hljs-string">"is not a number"</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Same logic as above, sort of. Don’t bother with comparisons if this
doesn’t pass.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (options.onlyInteger &amp;&amp; !v.isInteger(value)) {
        <span class="hljs-keyword">return</span> options.message || <span class="hljs-keyword">this</span>.notInteger  || <span class="hljs-string">"must be an integer"</span>;
      }

      <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> checks) {
        count = options[name];
        <span class="hljs-keyword">if</span> (v.isNumber(count) &amp;&amp; !checks[name](value, count)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>This picks the default message if specified
For example the greaterThan check uses the message from
this.notGreaterThan so we capitalize the name and prepend “not”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> msg = <span class="hljs-keyword">this</span>[<span class="hljs-string">"not"</span> + v.capitalize(name)] ||
            <span class="hljs-string">"must be %{type} %{count}"</span>;

          errors.push(v.format(msg, {
            count: count,
            type: v.prettify(name)
          }));
        }
      }

      <span class="hljs-keyword">if</span> (options.odd &amp;&amp; value % <span class="hljs-number">2</span> !== <span class="hljs-number">1</span>) {
        errors.push(<span class="hljs-keyword">this</span>.notOdd || <span class="hljs-string">"must be odd"</span>);
      }
      <span class="hljs-keyword">if</span> (options.even &amp;&amp; value % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) {
        errors.push(<span class="hljs-keyword">this</span>.notEven || <span class="hljs-string">"must be even"</span>);
      }

      <span class="hljs-keyword">if</span> (errors.length) {
        <span class="hljs-keyword">return</span> options.message || errors;
      }
    },
    datetime: v.extend(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, options)</span> </span>{
      <span class="hljs-keyword">if</span> (!v.isDefined(value)) {
        <span class="hljs-keyword">return</span>;
      }

      options = v.extend({}, <span class="hljs-keyword">this</span>.options, options);

      <span class="hljs-keyword">var</span> err
        , errors = []
        , earliest = options.earliest ? <span class="hljs-keyword">this</span>.parse(options.earliest, options) : <span class="hljs-literal">NaN</span>
        , latest = options.latest ? <span class="hljs-keyword">this</span>.parse(options.latest, options) : <span class="hljs-literal">NaN</span>;

      value = <span class="hljs-keyword">this</span>.parse(value, options);

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(value) || options.dateOnly &amp;&amp; value % <span class="hljs-number">86400000</span> !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> options.message || <span class="hljs-keyword">this</span>.notValid || <span class="hljs-string">"must be a valid date"</span>;
      }

      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(earliest) &amp;&amp; value &lt; earliest) {
        err = <span class="hljs-keyword">this</span>.tooEarly || <span class="hljs-string">"must be no earlier than %{date}"</span>;
        err = v.format(err, {date: <span class="hljs-keyword">this</span>.format(earliest, options)});
        errors.push(err);
      }

      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(latest) &amp;&amp; value &gt; latest) {
        err = <span class="hljs-keyword">this</span>.tooLate || <span class="hljs-string">"must be no later than %{date}"</span>;
        err = v.format(err, {date: <span class="hljs-keyword">this</span>.format(latest, options)});
        errors.push(err);
      }

      <span class="hljs-keyword">if</span> (errors.length) {
        <span class="hljs-keyword">return</span> options.message || errors;
      }
    }, {</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>This is the function that will be used to convert input to the number
of millis since the epoch.
It should return NaN if it’s not a valid date.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      parse: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, options)</span> </span>{
        <span class="hljs-keyword">if</span> (v.isFunction(root.XDate)) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> root.XDate(value, <span class="hljs-literal">true</span>).getTime();
        }

        <span class="hljs-keyword">var</span> moment = v.tryRequire(<span class="hljs-string">"moment"</span>) || root.moment;
        <span class="hljs-keyword">if</span> (v.isDefined(moment)) {
          <span class="hljs-keyword">return</span> +moment.utc(value);
        }

        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Neither XDate or moment.js was found"</span>);
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Formats the given timestamp. Uses ISO8601 to format them.
If options.dateOnly is true then only the year, month and day will be
output.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      format: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(date, options)</span> </span>{
        <span class="hljs-keyword">var</span> format = options.dateFormat;

        <span class="hljs-keyword">if</span> (v.isFunction(root.XDate)) {
          format = format || (options.dateOnly ? <span class="hljs-string">"yyyy-MM-dd"</span> : <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> XDate(date, <span class="hljs-literal">true</span>).toString(format);
        }

        <span class="hljs-keyword">var</span> moment = v.tryRequire(<span class="hljs-string">"moment"</span>) || root.moment;
        <span class="hljs-keyword">if</span> (v.isDefined(moment)) {
          format = format || (options.dateOnly ? <span class="hljs-string">"YYYY-MM-DD"</span> : <span class="hljs-string">"YYYY-MM-DD HH:mm:ss"</span>);
          <span class="hljs-keyword">return</span> moment.utc(date).format(format);
        }

        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Neither XDate or moment.js was found"</span>);
      }
    }),
    date: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, options)</span> </span>{
      options = v.extend({}, options, {dateOnly: <span class="hljs-literal">true</span>});
      <span class="hljs-keyword">return</span> v.validators.datetime.call(v.validators.datetime, value, options);
    },
    format: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, options)</span> </span>{
      <span class="hljs-keyword">if</span> (v.isString(options) || (options <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>)) {
        options = {pattern: options};
      }

      options = v.extend({}, <span class="hljs-keyword">this</span>.options, options);

      <span class="hljs-keyword">var</span> message = options.message || <span class="hljs-keyword">this</span>.message || <span class="hljs-string">"is invalid"</span>
        , pattern = options.pattern
        , match;

      <span class="hljs-keyword">if</span> (!v.isDefined(value)) {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">if</span> (!v.isString(value)) {
        <span class="hljs-keyword">return</span> message;
      }

      <span class="hljs-keyword">if</span> (v.isString(pattern)) {
        pattern = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(options.pattern, options.flags);
      }
      match = pattern.exec(value);
      <span class="hljs-keyword">if</span> (!match || match[<span class="hljs-number">0</span>].length != value.length) {
        <span class="hljs-keyword">return</span> message;
      }
    },
    inclusion: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, options)</span> </span>{
      <span class="hljs-keyword">if</span> (!v.isDefined(value)) {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">if</span> (v.isArray(options)) {
        options = {within: options};
      }
      options = v.extend({}, <span class="hljs-keyword">this</span>.options, options);
      <span class="hljs-keyword">if</span> (v.contains(options.within, value)) {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">var</span> message = options.message ||
        <span class="hljs-keyword">this</span>.message ||
        <span class="hljs-string">"^%{value} is not included in the list"</span>;
      <span class="hljs-keyword">return</span> v.format(message, {value: value});
    },
    exclusion: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, options)</span> </span>{
      <span class="hljs-keyword">if</span> (!v.isDefined(value)) {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">if</span> (v.isArray(options)) {
        options = {within: options};
      }
      options = v.extend({}, <span class="hljs-keyword">this</span>.options, options);
      <span class="hljs-keyword">if</span> (!v.contains(options.within, value)) {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">var</span> message = options.message || <span class="hljs-keyword">this</span>.message || <span class="hljs-string">"^%{value} is restricted"</span>;
      <span class="hljs-keyword">return</span> v.format(message, {value: value});
    },
    email: v.extend(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, options)</span> </span>{
      options = v.extend({}, <span class="hljs-keyword">this</span>.options, options);
      <span class="hljs-keyword">var</span> message = options.message || <span class="hljs-keyword">this</span>.message || <span class="hljs-string">"is not a valid email"</span>;
      <span class="hljs-keyword">if</span> (!v.isDefined(value)) {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">if</span> (!v.isString(value)) {
        <span class="hljs-keyword">return</span> message;
      }
      <span class="hljs-keyword">if</span> ((<span class="hljs-regexp">/^\s*$/</span>).test(value)) {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.PATTERN.exec(value)) {
        <span class="hljs-keyword">return</span> message;
      }
    }, {
      PATTERN: <span class="hljs-regexp">/^[a-z0-9\u007F-\uffff!#$%&amp;'*+\/=?^_`{|}~-]+(?:\.[a-z0-9\u007F-\uffff!#$%&amp;'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$/i</span>
    })
  };

  validate.exposeModule(validate, root, exports, <span class="hljs-built_in">module</span>, define);
}).call(<span class="hljs-keyword">this</span>,
        <span class="hljs-keyword">typeof</span> exports !== <span class="hljs-string">'undefined'</span> ? exports : <span class="hljs-literal">null</span>,
        <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> !== <span class="hljs-string">'undefined'</span> ? <span class="hljs-built_in">module</span> : <span class="hljs-literal">null</span>,
        <span class="hljs-keyword">typeof</span> define !== <span class="hljs-string">'undefined'</span> ? define : <span class="hljs-literal">null</span>,
        <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span> !== <span class="hljs-string">'undefined'</span> ? <span class="hljs-built_in">require</span> : <span class="hljs-literal">null</span>);</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
